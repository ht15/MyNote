# 编码思路

数据从客户端经过序列化为二进制流发往服务端，到服务端收到字节流并反序列化为特定类型的数据。这个过程能成功执行，序列化时一定对数据做了标记，以便反序列化时用到。

protocol buffers在其中所做的标记是这样的：

- 首先，每个字节的有效位是低7位，最高一位用来表示某一个数据是否结束，0则表示数据结束，1则表示数据未结束直到遇到最高位为0的字节

- 其次每个message的第一个数据信息代表的是 **field_num + 3位bite的wire type**，反序列化时会根据.proto中**独特的field_num**找到对应数据的类型，也就是说field_num非常重要

  

所以对于如下的定义：

```protobuf
message Test1 {
  optional int32 a = 1;
}
```

如果创建了Test1并把a赋值为150，那么得到的序列化字节流为：

```shell
08 96 01
```

按照上面的编码规则对此分析：

- 08（00001000）对应的是**field_num + 3位bite的wire type**，最高位为0表示数据已到头，去掉最高位得到**0001000**，所以field_num=1，wire type=0。

- 因为wire type为0所以接下来的就是a的值了（如果wire type是2，则表示变长类型，后面会紧跟表示数据长度的信息）。

- 96 01按上面分析表示的是一条数据（最高0表示到头），去掉最高位后数据为：

  ```shell
   1001 0110 0000 0001
  → 001 0110  000 0001
  ```

  此时最终数据不是0010110 0000001，而是要做一个翻转：0000001 0010110也就是10010110=128+16+4+2=150



## 特殊记录

- 嵌套的message被当成string来处理
- Field num一旦确定下来就不要更改，被删除了也要标记为reserved防止之后被重新用到；还有个技巧就是将15位以下的field num分配给经常使用到的数据（15以下只需要一bite）
- 新field生产的code解析旧消息时应该提供个默认值。 旧代码收到新消息时，新字段会被忽略。
- 目标proto文件 至少要在某一个IMPORT_PATH中找到
- 负数应该使用**sint32**而不是**int32**，**sin32**会使用zigzag编码即```Zigzag(n) = (n << 1) ^ (n >> 31)```
- package相当于c++中的namespace



### 疑问

- repeated 关键字

