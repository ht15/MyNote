# 升级GCC版本到8.3(可以与原先的gcc版本共存)

## 1. 下载GCC8.3源码(附件中也有)

&emsp;&emsp;GCC的源码仓库地址为: [https://github.com/gcc-mirror/gcc](gcc的Git地址) ,在浏览器打开这个网址后，不要急于下载，先选择gcc的版本，找到GCC8.3, 并点击 "releases/gcc-8.3.0"完成仓库的切换, 进入自己的home目录执行如下命令:

```shell
git clone --branch releases/gcc-8.3.0 https://github.com/gcc-mirror/gcc.git
```

也可以直接在网页上下载zip包, 然后自行上传至服务器后解压, 效果与直接使用git命令一致:

```shell
unzip gcc-releases-gcc-8.3.0.zip
```

获取完成源代码后, 将当前目录切换到GCC源码根目录, 进入下一步. 源码目录如下图所示:

## 2.安装依赖库

&emsp;&emsp;新的GCC源码内置了依赖库的获取脚本, GCC所依赖的mpfr, gmp, mpc, isl都可以使用内置脚本直接获取, 比老版本简单非常多, 
在GCC目录下, 执行:

```shell
./contrib/download_prerequisites
```

此命名会自动下载GCC编译需要的几个依赖库. 

## 3.配置和编译

配置命令如下 :

```shell
 ./configure --prefix=/usr/local/gcc-8.3.0 --enable-bootstrap --enable-languages=c,c++ --enable-threads=posix --enable-checking=release --enable-multilib --with-system-zlib
```

```shell
make -j48
```

进入root权限执行安装命令. **记得一定要root权限, 不然可能会因为权限不足安装失败.**

```shell
sudo -s
make install
```

&emsp;&emsp;这时整个gcc的安装过程已经成功执行完成, 按如下方法测试GCC是否正确安装:

```shell
/usr/local/gcc-8.3.0/bin/gcc --version
```

测试原先的版本：

```
gcc --version
```

两者都能够正确的访问.

## 4. CMake中指定需要的GCC版本

&emsp;&emsp;可以直接在shell中对CC和CXX进行指定:

```shell
export CC=/usr/local/gcc-8.3.0/bin/gcc
export CXX=/usr/local/gcc-8.3.0/bin/g++
cmake /path/to/your/project
make
```

&emsp;&emsp;也可以直接在cmake的命令行参数中进行指定:

```shell
cmake -D CMAKE_C_COMPILER=/usr/local/gcc-8.3.0/bin/gcc -D CMAKE_CXX_COMPILER=/usr/local/gcc-8.3.0/bin/g++
```

## 5. 运行GCC8.3

&emsp;&emsp;因为我们不是替换安装的方式, 所以运行需要的库默认是没有被添加到系统路径下的, 我们还需要额外的一步操作才能让gcc8.3编译出的程序正常的运行:

```shell
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/gcc-8.3.0/lib64
```

可以直接将本行追加到~/.bashrc, 避免每次都单独写shell脚本追加该项. 注意更改~/.bashrc后记得重新连接终端, 让修改生效.

## 6. 多GCC版本导致的ABI兼容问题

&emsp;&emsp;需要特别注意的是ABI兼容的问题, 有部分库我们可能是直接使用的第三方的, 没有源码, 那么可能对应库依然是使用GCC4.8编译的, 默认开启C++11后GCC会同样更改应用程序的ABI到CX11, 与老的库不兼容, 产生的报错.

临时的解决方案是在编译的时候添加宏-D_GLIBCXX_USE_CXX11_ABI=0, 禁止编译器使用新的ABI格式, 这样就能与老的GCC4.8的库共存了. 宏一般直接追加到CMake文件中即可

```
add_definitions(-D_GLIBCXX_USE_CXX11_ABI=0)
```

